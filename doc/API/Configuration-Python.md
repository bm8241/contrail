# API Guide - Configuration Python API

# 1 Overview

Python API is the Python wrapper of REST API. It's generated by [generateDS](https://github.com/Juniper/contrail-api-client/tree/master/generateds) based on data model XSD.

Python API is installed from package python-contrail to Python library directory, `/usr/lib/python2.7/site-packages/vnc_api` in container.


# 1.1 Client

The following Python libraries are required to run API client.
* vnc_api
* cfgm_common

They are installed in the container of configuration API server on Contrail controller during deployment. To run client out of the container, one option is to create a sandbox/directory, copy libraries there and run client there. The sandbox can be created anywhere having connectivity to API server.

Here is an example to create a sandbox on the controller.
```
mkdir -p sandbox
cd sandbox
docker cp config_api_1:/usr/lib/python2.7/site-packages/vnc_api ./
docker cp config_api_1:/usr/lib/python2.7/site-packages/cfgm_common ./
```

## 1.2 Reference

The best Python API reference is the API code. It's very self-explained with all details.

* vnc_api/vnc_api.py
* vnc_api/gen/resource_common.py
* vnc_api/gen/resource_xsd.py


# 2 Examples for Python API

## 2.1 Connect to API server

Here is an example for the client to connect to configuration API server.
```
from vnc_api import vnc_api

vnc = vnc_api.VncApi(
        username = "admin",
        password = "password",
        tenant_name = "admin",
        api_server_host = "10.1.1.1",
        auth_host = "10.1.1.2")
```


## 2.2 IPAM

### 2.2.1 Create IPAM
```
"""
name: IPAM name
tenant_name: tenant name
"""
tenant = vnc.project_read(fq_name = ['default-domain', tenant_name])
ipam = vnc_api.NetworkIpam(name = name, parent_obj = tenant)
vnc.network_ipam_create(ipam)
```


## 2.3 Policy

### 2.3.1 Create Policy
```
"""
name: policy name
tenant_name: tenant name
"""
tenant = vnc.project_read(fq_name = ['default-domain', tenant_name])
rule = vnc_api.PolicyRuleType(
        direction = '<>',
        protocol = 'any',
        action_list = vnc_api.ActionListType(simple_action = 'pass'),
        src_addresses = [vnc_api.AddressType(virtual_network = 'any')],
        src_ports = [vnc_api.PortType(start_port = -1, end_port = -1)],
        dst_addresses = [vnc_api.AddressType(virtual_network = 'any')],
        dst_ports = [vnc_api.PortType(start_port = -1, end_port = -1)])
policy = vnc_api.NetworkPolicy(name = name, parent_obj = tenant,
        network_policy_entries = vnc_api.PolicyEntriesType([rule]))
vnc.network_policy_create(policy)
```


## 2.4 Virtual Network

### 2.4.1 Create Virtual Network
```
"""
name: virtual network name
tenant_name: tenant name
ipam_name: IPAM name
cidr: subnet CIDR
"""
tenant = vnc.project_read(fq_name = ['default-domain', tenant_name])
vn = vnc_api.VirtualNetwork(name = name, parent_obj = tenant)
ipam = vnc.network_ipam_read(
        fq_name = ['default-domain', tenant_name, ipam_name])
prefix, prefix_len = cidr.split('/')
subnet = vnc_api.SubnetType(
        ip_prefix = prefix, ip_prefix_len = prefix_len)
ipam_subnet = vnc_api.IpamSubnetType(subnet = subnet)
vn.set_network_ipam(
        ref_obj = ipam,
        ref_data = vnc_api.VnSubnetsType([ipam_subnet]))
vnc.virtual_network_create(vn)
```


### 2.4.2 Attach Policy
```
"""
name: virtual network name
tenant_name: tenant name
policy_name: policy name
"""
policy = vnc.network_policy_read(
        fq_name = ['default-domain', tenant_name, policy_name])
policy_type = vnc_api.VirtualNetworkPolicyType(
        sequence = vnc_api.SequenceType(major = 0, minor = 0))
vn = vnc.virtual_network_read(
        fq_name = ['default-domain', tenant_name, name])
vn.add_network_policy(ref_obj = policy, ref_data = policy_type)
vnc.virtual_network_update(vn)
```


### 2.4.3 Set Route Target
```
"""
name: virtual network name
tenant_name: tenant name
policy_name: policy name
route_target: route target
    <number>:<number>
"""
vn = vnc.virtual_network_read(
        fq_name = ['default-domain', tenant_name, name])
route_targets = vnc_api.RouteTargetList(['target:' + route_target])
vn.set_route_target_list(route_targets)
vnc.virtual_network_update(vn)
```


## 2.5 Subnet
[https://github.com/Juniper/contrail-controller/wiki/Subnet-Options](https://github.com/Juniper/contrail-controller/wiki/Subnet-Options)

Each virtual network can have one or multiple subnets. Each subnet has its own IPAM, like gateway, DNS, DHCP, address space, etc. Network policy don't apply to the traffic across subnets in the same virtual network.


### 2.5.1 Attach Subnet
```
"""
tenant_name: tenant name
vn_name: virtual network name
ipam_name: IPAM name
cidr: subnet CIDR
"""
vn = vnc.virtual_network_read(
        fq_name = ['default-domain', tenant_name, vn_name])
ipam = vnc.network_ipam_read(
        fq_name = ['default-domain', tenant_name, ipam_name])
ipam_subnet = vnc_api.IpamSubnetType()
prefix, prefix_len = cidr.split('/')
subnet = vnc_api.SubnetType(
        ip_prefix = prefix, ip_prefix_len = prefix_len)
ipam_subnet.set_subnet(subnet)
vn.add_network_ipam(
        ref_obj = ipam,
        ref_data = vnc_api.VnSubnetsType([ipam_subnet]))
vnc.virtual_network_update(vn)
```


### 2.5.2 Gateway
If gateway address is not specified by user, the last available address from the subnet will be allocated.

If gateway address is set to '0.0.0.0', gateway is disabled. DHCP option 'routers' has to be manually set to the address of some other machine who will act as the gateway. The last available address is also freed.
```
"""
tenant_name: tenant name
vn_name: virtual network name
ipam_name: IPAM name
cidr: subnet CIDR
gateway_address: gateway address
"""
vn = vnc.virtual_network_read(
        fq_name = ['default-domain', tenant_name, vn_name])
ipam = vnc.network_ipam_read(
        fq_name = ['default-domain', tenant_name, ipam_name])
ipam_subnet = vnc_api.IpamSubnetType()
prefix, prefix_len = cidr.split('/')
subnet = vnc_api.SubnetType(
        ip_prefix = prefix, ip_prefix_len = prefix_len)
ipam_subnet.set_subnet(subnet)
ipam_subnet.set_default_gateway(gateway_address)
vn.add_network_ipam(ref_obj = ipam,
        ref_data = vnc_api.VnSubnetsType([ipam_subnet]))
vnc.virtual_network_update(vn)
```


### 2.5.3 Service Address
Service address is for providing DHCP and DNS services. If it's not specified by user, the second to the last available address from the subnet will be allocated. If it's set to '0.0.0.0', gateway address will be used to provide services as well. If both gateway address and service address are '0.0.0.0', then gateway is disabled and the last available address is allocated to be service address. Service address is always allocated.
```
"""
tenant_name: tenant name
vn_name: virtual network name
ipam_name: IPAM name
cidr: subnet CIDR
service_address: service address
"""
vn = vnc.virtual_network_read(
        fq_name = ['default-domain', tenant_name, vn_name])
ipam = vnc.network_ipam_read(
        fq_name = ['default-domain', tenant_name, ipam_name])
ipam_subnet = vnc_api.IpamSubnetType()
prefix, prefix_len = cidr.split('/')
subnet = vnc_api.SubnetType(
        ip_prefix = prefix, ip_prefix_len = prefix_len)
ipam_subnet.set_subnet(subnet)
ipam_subnet.set_dns_server_address(service_address)
vn.add_network_ipam(ref_obj = ipam,
        ref_data = vnc_api.VnSubnetsType([ipam_subnet]))
vnc.virtual_network_update(vn)
```


### 2.5.4 DNS
Service address is sent to client by DHCP option 'domain-name-servers' as the DNS server address. In this case, DNS request is trapped by vrouter. If DNS service from Contrail is not wanted, DHCP option 'domain-name-servers' can by set by user to some other address.


### 2.5.5 DHCP
DHCP service is provided on service address. If DHCP service is disabled, DHCP request will be broadcast.
```
"""
tenant_name: tenant name
vn_name: virtual network name
ipam_name: IPAM name
cidr: subnet CIDR
enable_dhcp: true | false
"""
vn = vnc.virtual_network_read(
        fq_name = ['default-domain', tenant_name, vn_name])
ipam = vnc.network_ipam_read(
        fq_name = ['default-domain', tenant_name, ipam_name])
ipam_subnet = vnc_api.IpamSubnetType()
prefix, prefix_len = cidr.split('/')
subnet = vnc_api.SubnetType(
        ip_prefix = prefix, ip_prefix_len = prefix_len)
ipam_subnet.set_subnet(subnet)
ipam_subnet.set_enable_dhcp(enable_dhcp)
vn.add_network_ipam(ref_obj = ipam,
        ref_data = vnc_api.VnSubnetsType([ipam_subnet]))
vnc.virtual_network_update(vn)
```


## 2.6 Floating IP

### 2.6.1 Create Floating IP Pool
```
"""
name: FIP pool name
tenant_name: tenant name
vn_name: virtual network name
"""
vn = vnc.virtual_network_read(
        fq_name = ['default-domain', tenant_name, vn_name])
pool = vnc_api.FloatingIpPool(name = name, parent_obj = vn)
vnc.floating_ip_pool_create(pool)

#  Add reference to floating IP pool in the tenant who will need to
#  allocate floating IP.
tenant = vnc.project_read(fq_name = ['default-domain', tenant_name])
tenant.add_floating_ip_pool(pool)
vnc.project_update(tenant)
```


### 2.6.2 Allocate Floating IP
```
"""
tenant_name: tenant name
vn_name: virtual network name
pool_name: FIP pool name
"""
id = str(uuid.uuid4())
pool = vnc.floating_ip_pool_read(
        fq_name = 'default-domain', tenant_name, vn_name, pool_name])
fip = vnc_api.FloatingIp(name = id, parent_obj = pool)
fip.uuid = id
vnc.floating_ip_create(fip)
```


### 2.6.3 Associate Floating IP
```
"""
tenant_name: tenant name
fip_id: floating IP UUID
vmi_id: virtual machine interface UUID
"""
vmi = vnc.virtual_machine_interface_read(id = vmi_id)
tenant = vnc.project_read(fq_name = ['default-domain', tenant_name])
fip = vnc.floating_ip_read(id = fip_id)
fip.add_project(tenant)
fip.add_virtual_machine_interface(vmi)
vnc.floating_ip_update(fip)
```


## 2.7 Service Chain V1

### 2.7.1 Create Service Template
```
"""
name: service template name
mode: service mode
type: service type
image_name: image name
"""
template = vnc_api.ServiceTemplate(name = name)
properties = vnc_api.ServiceTemplateType(
        service_mode = mode, service_type = type, image_name = image_name)
properties.add_interface_type(
        vnc_api.ServiceTemplateInterfaceType(
            service_interface_type = 'left',
            shared_ip = False))
properties.add_interface_type(
        vnc_api.ServiceTemplateInterfaceType(
            service_interface_type = 'right',
            shared_ip = False))
template.set_service_template_properties(properties)
vnc.service_template_create(template)
```


### 2.7.2 Create Service Instance
```
tenant = vnc.project_read(fq_name = ['default-domain', tenant_name])
instance = vnc_api.ServiceInstance(name = name, parent_obj = tenant)
properties = vnc_api.ServiceInstanceType(
        scale_out = vnc_api.ServiceScaleOutType())
instance.set_service_instance_properties(properties)
instance.set_service_template(template)
vnc.service_instance_create(instance)
```


### 2.7.3 Create Service Policy
Create a service chain policy. Attach the service policy to the left and right virtual networks. All traffic between left and right virtuan networks will go through the service chain as the order defined in service policy.
```
rule = vnc_api.PolicyRuleType(
        direction = '<>',
        protocol = 'any',
        action_list = vnc_api.ActionListType(
            apply_service = ['default-domain:demo:firewall']),
        src_addresses = [vnc_api.AddressType(
            virtual_network = 'default-domain:demo:left-vn')],
        src_ports = [vnc_api.PortType(start_port = -1, end_port = -1)],
        dst_addresses = [vnc_api.AddressType(
            virtual_network = 'default-domain:demo:right-vn')],
        dst_ports = [vnc_api.PortType(start_port = -1, end_port = -1)])
policy = vnc_api.NetworkPolicy(
        name = 'policy-firewall',
        parent_obj = tenant,
        network_policy_entries = vnc_api.PolicyEntriesType([rule]))
vnc.network_policy_create(policy)
```


## 2.8 Service Chain V2

### 2.8.1 Create Service Template
```
"""
name: service template name
mode: service mode
type: service type
vn_list: list of virtual networks
    [ 'management'=<VN name>, 'left'=<VN name>, 'right'=<VN name> ]
"""
st = vnc_api.ServiceTemplate(name = name)
properties = vnc_api.ServiceTemplateType(version = 2,
        service_mode = mode, service_type = type,
        ordered_interfaces = True)
for vn in vn_list:
    type_name, vn_name = vn.split('=')
    type = vnc_api.ServiceTemplateInterfaceType(
                service_interface_type = type_name)
    properties.add_interface_type(type)
 st.set_service_template_properties(properties)
 vnc.service_template_create(st)
```


### 2.8.2 Create Service Instance
```
"""
name: service template name
tenant_name: tenant name
template_name: service template name
vn_list: list of virtual networks
    [ 'management'=<VN name>, 'left'=<VN name>, 'right'=<VN name> ]
port_tuple_list: list of port tuples
    [[ 'management'=<port ID>, 'left'=<port ID>, 'right'=<port ID> ]]
"""
tenant = vnc.project_read(fq_name = ['default-domain', tenant_name])
st = vnc.service_template_read(fq_name = ['default-domain', template_name])
si_id = str(uuid.uuid4())
si = vnc_api.ServiceInstance(name = name, parent_obj = tenant)
si.uuid = si_id
si.add_service_template(st)

#  Set interface list for service instance. The order has to be the
#  same as that in service template.
properties = vnc_api.ServiceInstanceType()
network = {}
for arg in vn_list:
    type_name, vn_name = arg.split('=')
    network[type] = vn_name
st_properties = st.get_service_template_properties()
for st_interface in st_properties.get_interface_type():
    type = st_interface.get_service_interface_type()
    interface = vnc_api.ServiceInstanceInterfaceType()
    interface.set_virtual_network(network[type])
    properties.add_interface_list(interface)

pt_list = []
for port_list in port_tuple_list:
    pt = {}
    for port_args in port_list:
        port_type, port_id = port_args.split('=')
        vmi = vnc.virtual_machine_interface_read(id = port_id)
        pt[port_type] = vmi
    pt_list.append(pt)

#  The service instance IP (VIP of each network) will be created
#  by service monitor.
si.set_service_instance_properties(properties)

#  Create service instance.
vnc.service_instance_create(si)

#  Create port tuples.
idx = 0
for tuple in pt_list:
    name = si.display_name + '-port-tuple-' + str(idx)
    idx += 1
    pt = vnc_api.PortTuple(name = name, parent_obj = si)
    vnc.port_tuple_create(pt)

    #  Update VMIs to refer to the port tuple.
    for type in tuple.keys():
        tuple[type].add_port_tuple(pt)
        vnc.virtual_machine_interface_update(tuple[type])
```


## 2.9 DNS
[https://github.com/Juniper/contrail-controller/wiki/DNS-and-IPAM](https://github.com/Juniper/contrail-controller/wiki/DNS-and-IPAM)

There are 4 options to configure DNS service for VM instance. When creating virtual network with subnet, by default, the first available address is the gateway address, the second available address is the service address providing DNS, DHCP and other services.
* No DNS: DNS server is set by DHCP to VM, but no DNS service is provided.
* Default DNS: This is the default type when no DNS configuration is provided. DNS server is set by DHCP to VM. DNS request is from VM to DNS server (vRouter), to vRouter agent, to the compute node host and resolved by DNS configuration on the host.
* Tenant DNS: DNS service is provided by tenant. DNS server is set to be tenant DNS server(s) by DHCP. DNS server could be some VM in virtual network or server in physical network, as long as it's reachable to VM.
* Virtual DNS: vDNS service runs on controller. DNS request is from VM to DNS server (vRouter), to vRouter agent, to control node and resolved by vDNS service. vDNS has an option of the next DNS server (forwarder). Total 16 servers can be chained together. There are 3 types of next DNS server.
  * Default, is provided by DNS on controller.
  * vDNS, is provided by another vDNS on controller.
  * Fabric, is provided by any DNS server that is reachable by control node.


### 2.9.1 Create virtual DNS
Create a virtual DNS. The next_virtual_DNS could be 'None', or the name of another virtual DNS server, or the IP address of DNS server reachable by fabric.
```
"""
name: vDNS name
domain_name: domain name
"""
vdns = vnc_api.VirtualDns(name = name)
data = vnc_api.VirtualDnsType(
        domain_name = domain_name,
        dynamic_records_from_client = True,
        record_order = 'random',
        default_ttl_seconds = 86400,
        next_virtual_DNS = 'default-domain:another-virtual-dns')
vdns.set_virtual_DNS_data(data)
vnc.virtual_DNS_create(vdns)
```


### 2.9.2 Update IPAM with vDNS
```
"""
ipam_name: IPAM name
tenant_name: tenant name
vdns_name: vDNS name
"""
ipam = vnc.network_ipam_read(
        fq_name = ['default-domain', tenant_name, ipam_name])
mgmt = ipam.get_network_ipam_mgmt()
if not mgmt:
    mgmt = vnc_api.IpamType()
mgmt.set_ipam_dns_method('virtual-dns-server')
mgmt.set_ipam_dns_server(
        vnc_api.IpamDnsAddressType(virtual_dns_server_name = vdns_name))
ipam.set_network_ipam_mgmt(mgmt)
vnc.network_ipam_update(ipam)
```


## 2.10 DHCP Option
[https://github.com/Juniper/contrail-controller/wiki/Extra-DHCP-Options](https://github.com/Juniper/contrail-controller/wiki/Extra-DHCP-Options)

DHCP options can be configured on the following objects.
* IPAM, options will apply on all subnets associated with this IPAM and all ports on subnets.
* Subnet, options will apply on all ports on this subnet.
* Port, options will apply on this port only.
The options to port is the union of all above and the options on more specific object take precedence.


### 2.10.1 DHCP Options on IPAM
```
"""
tenant_name: tenant name
ipam_name: IPAM name
option_list: DHCP options list
    ['<option name>=<option value>', ......]
"""
ipam = vnc.network_ipam_read(
        fq_name = ['default-domain', tenant_name, ipam_name])
ipam_mgmt = ipam.get_network_ipam_mgmt()
option_list = ipam_mgmt.get_dhcp_option_list()
if not option_list:
    option_list = vnc_api.DhcpOptionsListType()
for option_args in option_list:
    opt_name, opt_val = option_args.split('=')
    option = vnc_api.DhcpOptionType(opt_name, opt_val)
    option_list.add_dhcp_option(option)
ipam_mgmt.set_dhcp_option_list(option_list)
ipam.set_ipam_mgmt(ipam_mgmt)
vnc.network_ipam_update(ipam)
```


### 2.10.2 DHCP Options on Subnet
```
"""
tenant_name: tenant name
vn_name: virtual network name
ipam_name: IPAM name
cidr: subnet CIDR
option_list: DHCP options list
    ['<option name>=<option value>', ......]
"""
vn = vnc.virtual_network_read(
        fq_name = ['default-domain', tenant_name, vn_name])
ipam = vnc.network_ipam_read(
        fq_name = ['default-domain', tenant_name, ipam_name])
ipam_subnet = vnc_api.IpamSubnetType()
prefix, prefix_len = cidr.split('/')
subnet = vnc_api.SubnetType(
        ip_prefix = prefix, ip_prefix_len = prefix_len)
ipam_subnet.set_subnet(subnet)
option_list = vnc_api.DhcpOptionsListType()
for option_args in option_list:
    opt_name, opt_val = option_args.split('=')
    option = vnc_api.DhcpOptionType(opt_name, opt_val)
    option_list.add_dhcp_option(option)
ipam_subnet.set_dhcp_option_list(option_list)
vn.add_network_ipam(
        ref_obj = ipam,
        ref_data = vnc_api.VnSubnetsType([ipam_subnet]))
vnc.virtual_network_update(vn)
```


### 2.10.3 DHCP Options on Port
```
"""
port_id: port/VIM UUID
option_list: DHCP options list
    ['<option name>=<option value>', ......]
"""
port = vnc.virtual_machine_interface_read(id = port_id)
option_list = port.virtual_machine_interface_dhcp_option_list()
if not option_list:
    option_list = vnc_api.DhcpOptionsListType()
for option_args in option_list:
    opt_name, opt_val = option_args.split('=')
    option = vnc_api.DhcpOptionType(opt_name, opt_val)
    option_list.add_dhcp_option(option)
port.set_virtual_machine_interface_dhcp_option_list(options_list)
vnc.virtual_machine_interface_update(port)
```


## 2.11 CPE
A compute node equitped with vrouter can be configured as a CPE device and deployed at customer's premise. Customer can connect a subnet directly to the compute node or a local router to the compute node.

### 2.11.1 Create physical router
Create a CPE type of physical router based on vrouter default-global-system-config:cpe-acme.
```
gsc = vnc.global_system_config_read(
        fq_name = ['default-global-system-config'])
prouter = vnc_api.PhysicalRouter(
        name = 'cpe-acme',
        parent_obj = gsc,
        physical_router_management_ip = '10.1.1.1',
        physical_router_dataplane_ip = '10.1.1.1',
        physical_router_vendor_name = 'Juniper',
        physical_router_product_name = 'CPE',
        physical_router_vnc_managed = True,
        physical_router_user_credentials = vnc_api.UserCredentials(
            username = 'root',
            password = 'password'))
vrouter = vnc.virtual_router_read(
        fq_name = 'default-global-system-config:cpe-acme'.split(':'))
prouter.add_virtual_router(vrouter)
vnc.physical_router_create(prouter)
```


### 2.11.2 Create physical interface
Create a physical interface. The name has to match the interface name on CPE/vrouter node.
```
pif = vnc_api.PhysicalInterface(
        name = 'p1p1',
        parent_obj = prouter)
vnc.physical_interface_create(pif)
```


### 2.11.3 Create logical interface
Create logical interface and attach subnet to it.
```
#  Create a virtual network default-domain:demo:acme with
#  subnet 192.168.100.0/24 where IP address will be allocated from.

#  Create a VM interface on the virutual network.
id = str(uuid.uuid4())
vmi = vnc_api.VirtualMachineInterface(
        name = id,
        parent_obj = tenant)
vmi.uuid = id
vmi.add_virtual_network(vn)
vnc.virtual_machine_interface_create(vmi)

#  Choose a subnet from user virtual network (192.168.100.0/24 from acme),
#  create a user subnet and link it to the virtual machine interface.
id = str(uuid.uuid4())
subnet = vnc_api.Subnet(
        name = id,
        subnet_ip_prefix = vnc_api.SubnetType(
            ip_prefix = 192.168.100.0,
            ip_prefix_len = 24))
subnet.uuid = id
subnet.add_virtual_machine_interface(vmi)
vnc.subnet_create(subnet)

#  Create a logical interface and link it to the virtual machine interface.
lif = vnc_api.LogicalInterface(
        name = 'p1p1.0',
        parent_obj = pif,
        logical_interface_vlan_tag = 0,
        logical_interface_type = 'l3')
lif.add_virtual_machine_interface(vmi)
vnc.logical_interface_create(lif)
```


# 3 Examples for REST API

## 3.1 Token
The client has to connect to Keystone service to get authentication and token first. Then sends the token in the request to configuration API server.

curl -s \
    -H "X-Auth-Token: 2ecd20be919ac3c5cc98" \
    -H "Content-Type: application/json" \
    http://localhost:5000/v3/roles \
    | python -m json.tool

```
curl -s -X GET \
  -H "X-Auth-Token: $(openstack token issue | grep '| id' | awk '{print $4}')" \
  http://localhost:8082 \
  | python -m json.tool
```

## 3.2 List Resources

This is to get the list of all resources.
```
curl -s -X GET \
  -H "X-Auth-Token: $(openstack token issue | grep '| id' | awk '{print $4}')" \
  http://localhost:8082/ \
  | python -m json.tool | grep '"name"' | awk '{print $2}'
```

This is to get the list of specific resource.
```
curl -s -X GET \
  -H "X-Auth-Token: $(openstack token issue | grep '| id' | awk '{print $4}')" \
  http://localhost:8082/projects \
  | python -m json.tool
```

## 3.3 Get Resource
UUID or FQ (fully qualified) name is used to identify each resource object. UUID and FQ name is 1:1 mapping. UUID is used in the request to get resource.
```
curl -s -X GET \
  -H "X-Auth-Token: $(openstack token issue | grep '| id' | awk '{print $4}')" \
  http://localhost:8082/project/<project UUID> \
  | python -m json.tool | grep '"name"' | awk '{print $2}'
```

To use FQ name to get resource, it has to be mapped to UUID first, then use UUID in the request. This is to get UUID by FQ name.
```
curl -s -X POST \
  -H "X-Auth-Token: $(openstack token issue | grep '| id' | awk '{print $4}')" \
  -H "Content-Type: application/json" \
  -d '{"fq_name": ["default-domain", "admin"], "type": "project"}' \
  http://localhost:8082/fqname-to-id \
  | python -m json.tool

```

## 3.4 Service instance

For example, the followings are pre-configured.
* VN `management`, `vsrx-left` and `vsrx-right` in domain `default-domain` tenant `admin`.
* VM `vsrx` on all above 3 VNs.
* For service instance, VN `management` is the management network, `vsrx-left` is the left network and `vsrx-right` is the right network.

### Create service template `firewall`.

```
curl -s -X POST \
-H "Content-Type: application/json" \
-d '
{
    "service-template": {
        "parent_type": "domain",
        "fq_name": ["default-domain", "firewall"],
        "uuid": null,
        "service_template_properties": {
            "version": 2,
            "service_mode": "in-network",
            "service_type": "firewall",
            "service_scaling": false,
            "ordered_interfaces": true,
            "interface_type": [
                {
                    "service_interface_type": "management"
                },
                {
                    "service_interface_type": "left"
                },
                {
                    "service_interface_type": "right"
                }
            ]
        }
    }
}' http://10.6.11.2:8082/service-templates
```

### Create service instance `vsrx`.


